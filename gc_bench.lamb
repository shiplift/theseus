#!/usr/bin/env lamb

currentmilliseconds ≔ ⟪currentmilliseconds⟫
print_int ≔ ⟪print_int⟫
- ≔ ⟪-⟫
+ ≔ ⟪+⟫
/ ≔ ⟪/⟫
* ≔ ⟪*⟫

nil ≔ nil()


p$0 ≔ λ. 1. _, X ↦ X

p ≔ λ. 1. X ↦ μ(p$0, μ(print_int, X), X)

# append ≔ λ.
#          1. nil             , X ↦ X
#          2. Cons(Head, Tail), X ↦ Cons(Head, μ(append, Tail, X))

fromToByDo$cont0 ≔ λ.
                   1. _,    _ , _ , _ , Result, 0 ↦ Result
                   2. From, To, By, Do, Result, _ ↦ μ(fromToByDo$cont0,
                                                      μ(⟪+⟫, From, By), To, By, Do,
                                                      μ(Do, Result, From), μ(-, To, From))

fromToByDo ≔ λ.
             1. From, To, By, Do ↦ μ(fromToByDo$cont0,
                                      From, To, By, Do,
                                      nil, μ(-, To, From))

fromToDo ≔ λ.
           1. From, To, Do ↦ μ(fromToByDo, From, To, 1, Do)

# plus_nil_aware ≔ λ.
#                  1. nil, Y ↦ Y
#                  2. X,   Y ↦ μ(⟪+⟫, X, Y)
#
# μ(print_int, μ(fromToDo, 1, 10, plus_nil_aware))
###############################################################################

kStretchTreeDepth ≔ 18
kMinTreeDepth ≔ 4
kMaxTreeDepth ≔ 16

MakeTree ≔ λ.
           1. 0      ↦ Node(nil, nil)
           2. iDepth ↦ Node(μ(MakeTree, μ(-, iDepth, 1)),
                            μ(MakeTree, μ(-, iDepth, 1)))

<< ≔ λ.
     1. X, 0 ↦ X
     2. X, Y ↦ μ(<<, μ(*, X, 2), μ(-, Y, 1))

TreeSize ≔ λ. 1. i ↦ μ(-, μ(<<, 1, μ(+, i, 1)), 1)

NumIters ≔ λ. 1. i ↦ μ(/,
                        μ(*,
                          2,
                          μ(TreeSize, kStretchTreeDepth)),
                        μ(TreeSize, i))


TimeConstruction$cont2 ≔ λ.
                         1. 1,    iNumIters, depth, _ ↦ nil
                         2. Diff, iNumIters, depth, _ ↦ μ(TimeConstruction$cont2,
                                                          μ(-, iNumIters, Diff), μ(-, iNumIters, 1), depth,
                                                          μ(MakeTree, depth))

TimeConstruction$cont1 ≔ λ.
                         1. iNumIters, depth, _, _ ↦ μ(TimeConstruction$cont2, iNumIters, iNumIters, depth, nil)

TimeConstruction$cont0 ≔ λ.
                         1. iNumIters, depth ↦ μ(TimeConstruction$cont1,
                                                 iNumIters, depth,
                                                 μ(print_int, iNumIters),
                                                 μ(print_int, depth))

TimeConstruction ≔ λ.
                   1. depth ↦ μ(TimeConstruction$cont0,  μ(NumIters, depth), depth)

mTimeConstruction ≔ λ.
                    1. _, depth ↦ μ(TimeConstruction, depth)

gc_bench$cont2 ≔ λ.
                 1. _ ↦ μ(fromToByDo, kMinTreeDepth, kMaxTreeDepth, 2, mTimeConstruction)

gc_bench$cont1 ≔ λ.
                 1. tStart, tFinish, _ ↦ μ(gc_bench$cont2,
                                           μ(print_int, μ(-, tFinish, tStart)))

gc_bench$cont0 ≔ λ.
                 1. tStart, root ↦ μ(gc_bench$cont1,
                                     tStart,
                                     μ(currentmilliseconds),
                                     root)

gc_bench$let0 ≔ λ.
                1. tStart ↦ μ(gc_bench$cont0,
                              tStart,
                              μ(MakeTree,
                                kStretchTreeDepth))

gc_bench ≔ λ.
           1. ↦ μ(gc_bench$let0,
                  μ(currentmilliseconds))

μ(gc_bench)
